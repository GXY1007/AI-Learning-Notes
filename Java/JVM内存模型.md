### JVM内存结构篇

------

#### **1. JVM 内存模型**

**🔑 知识点详解**

- JVM 运行时数据区域主要包括：

  - **堆（Heap）**：存储对象实例，垃圾回收的主要区域。
  - **栈（Stack）**：存储方法调用时的局部变量、操作数栈、帧数据。
  - **方法区（Method Area）**：存储类信息、常量池、静态变量等（JDK 8 之后由元空间 Metaspace 替代）。
  - **程序计数器（PC Register）**：指向当前执行的字节码指令地址。
  - **本地方法栈（Native Method Stack）**：为 JNI（Java Native Interface）调用提供支持。

  👉 注意：堆是 JVM 内存中最大的一部分，而栈是线程私有的。

**🔥 面试高频题**

1. **堆和栈的区别？**
   - **一句话答案**：堆存储对象，栈存储方法调用和局部变量。
   - **深入回答**：堆是所有线程共享的，主要存放对象实例，由 GC 负责回收；栈是线程私有的，每个方法调用时都会创建新的栈帧，存储局部变量、方法参数等，方法执行完毕后栈帧被销毁。
2. **方法区和堆的区别？**
   - **一句话答案**：方法区存储类元信息，堆存储实例对象。
   - **深入回答**：方法区（JDK 8 之后是元空间）存储已加载类的信息、静态变量、运行时常量池等，主要用于 Class 加载，而堆存储 new 出来的对象，二者在作用和存储内容上有明显区别。

------

### 垃圾回收算法与调优篇

------

#### **1. 垃圾回收基础**

**🔑 知识点详解**

- **垃圾回收（Garbage Collection, GC）**：自动管理内存，回收不再使用的对象，防止内存泄漏。

- 对象存活判断：

  - **引用计数法**（已弃用）：每个对象维护一个引用计数，计数为 0 时回收。无法解决循环引用问题。

  - 可达性分析法（Reachability Analysis）：从 GC Root 开始搜索，无法触及的对象被视为垃圾。

    GC Roots 包括：

    - JVM 栈中引用的对象（如局部变量）
    - 方法区中的静态变量和常量
    - JNI（Native 方法）引用的对象

- **对象回收流程**：两次标记后进入回收队列（finalize 机制已废弃）。

**🔥 面试高频题**

1. 如何判断对象是否可以被回收？
   - **一句话答案**：通过可达性分析判断是否可被 GC Roots 访问。
   - **深入回答**：JVM 采用可达性分析算法，若对象无法从 GC Roots 访问，则会被标记为“可回收”。对象可在第一次回收前自救（重写 `finalize()`），若仍无法访问，则在下一轮 GC 时被回收。

------

#### **2. 垃圾回收算法**

**🔑 知识点详解**

- **标记-清除（Mark-Sweep）**：标记可达对象，再清除不可达对象，存在内存碎片问题。
- **复制算法（Copying）**：将存活对象复制到新区域，效率高但浪费空间，适用于新生代 GC。
- **标记-整理（Mark-Compact）**：标记存活对象后，整理并移动到一侧，适用于老年代 GC。
- 分代回收策略：
  - **新生代（Young Generation）**：采用复制算法（Eden + Survivor 设计）。
  - **老年代（Old Generation）**：采用标记-整理或标记-清除算法，适合长期存活对象。
  - **永久代/元空间（Metaspace）**：存储类元信息，JDK 8 之后由元空间代替永久代。

**🔥 面试高频题**

1. 垃圾回收算法有哪些？新生代和老年代的 GC 策略有什么不同？
   - **一句话答案**：新生代采用复制算法，老年代采用标记-整理或标记-清除算法。
   - **深入回答**：
      新生代对象生命周期短，适合高效的复制算法，减少碎片。老年代对象存活时间长，采用标记-整理算法减少内存碎片，提高 GC 效率。JVM 通过分代 GC 机制提高整体回收性能。

------

#### **3. 常见 GC 垃圾收集器**

**🔑 知识点详解**

- **Serial GC（串行收集器）**：单线程，适用于小型应用（`-XX:+UseSerialGC`）。
- **Parallel GC（并行收集器）**：多线程收集，吞吐量优先（`-XX:+UseParallelGC`）。
- **CMS GC（并发标记清除）**：低停顿，适用于响应时间敏感场景（`-XX:+UseConcMarkSweepGC`）。
- **G1 GC（垃圾优先收集器）**：减少全局停顿，按分区回收（`-XX:+UseG1GC`）。
- **ZGC（低延迟 GC）**：超低停顿时间（`-XX:+UseZGC`，JDK 11+）。

**🔥 面试高频题**

1. CMS 和 G1 的区别是什么？
   - **一句话答案**：CMS 低停顿但易碎片化，G1 通过分区整理减少碎片，提高 GC 效率。
   - **深入回答**：
      CMS 采用并发标记清除，减少 STW（Stop-The-World）时间，但可能导致碎片化，需定期 `Full GC`。G1 通过区域（Region）管理对象，回收后整理内存，减少碎片，提高吞吐量和响应时间。

------

#### **4. GC 调优策略**

**🔑 知识点详解**

- 查看 GC 运行状态：
  - `-XX:+PrintGCDetails`：打印详细 GC 信息。
  - `jstat -gcutil <pid>`：监测 JVM GC 状态。
  - `jvisualvm`、`GCViewer`：可视化 GC 监控。
- 常见 GC 调优参数：
  - `-Xms` / `-Xmx`：设置堆内存大小。
  - `-XX:NewRatio`：设置新生代与老年代的比例。
  - `-XX:SurvivorRatio`：Eden 和 Survivor 空间比例。
  - `-XX:+UseG1GC`：启用 G1 收集器。
  - `-XX:+UseZGC`：启用 ZGC 收集器（JDK 11+）。

**🔥 面试高频题**

1. 如何分析和优化 GC？
   - **一句话答案**：使用 GC 日志、`jstat`、`jvisualvm` 等工具监控 GC，调整 JVM 参数优化回收性能。
   - **深入回答**：
      通过 `-XX:+PrintGCDetails` 观察 GC 频率、时间消耗，判断是否存在 `Full GC` 过频现象。如果 GC 停顿时间过长，可考虑使用 CMS/G1 代替 Parallel GC，适当调整新生代与老年代比例，减少对象晋升。对于低延迟应用，可启用 ZGC 进行优化。

------

### JVM 参数与性能监控篇

------

#### **1. JVM 参数分类**

**🔑 知识点详解**

JVM 提供了丰富的参数来调整内存管理、垃圾回收和性能优化，主要分为以下几类：

1. **内存管理参数**
   - `-Xms<size>`：初始堆大小，如 `-Xms512m`（单位：k、m、g）。
   - `-Xmx<size>`：最大堆大小，如 `-Xmx2g`。
   - `-Xmn<size>`：新生代大小。
   - `-XX:NewRatio=<n>`：新生代与老年代比例，如 `-XX:NewRatio=2`（1:2）。
   - `-XX:SurvivorRatio=<n>`：Eden 与 Survivor 比例，如 `-XX:SurvivorRatio=8`（Eden:Survivor=8:1:1）。
2. **GC 相关参数**
   - `-XX:+UseSerialGC`：使用串行 GC（适用于小内存场景）。
   - `-XX:+UseParallelGC`：使用并行 GC（吞吐量优先）。
   - `-XX:+UseConcMarkSweepGC`（CMS GC）：并发低停顿 GC。
   - `-XX:+UseG1GC`：使用 G1 GC（减少全局停顿）。
   - `-XX:+UseZGC`：启用 ZGC（超低延迟 GC，JDK 11+）。
   - `-XX:+PrintGCDetails`：打印 GC 详细信息。
   - `-XX:+HeapDumpOnOutOfMemoryError`：OOM 时自动生成 HeapDump 文件。
3. **JIT 编译器优化**
   - `-XX:+TieredCompilation`：分层编译，结合解释执行和 JIT。
   - `-XX:+PrintCompilation`：打印 JIT 编译过程。
4. **其他调优参数**
   - `-XX:+DisableExplicitGC`：禁用 `System.gc()` 调用的 GC。
   - `-XX:+AlwaysPreTouch`：启动时预分配所有内存，防止运行时分配开销。
   - `-XX:MaxMetaspaceSize=<size>`：最大元空间大小（JDK 8+）。

**🔥 面试高频题**

1. 如何调整 JVM 堆内存大小？
   - **一句话答案**：使用 `-Xms` 和 `-Xmx` 参数设置堆的初始值和最大值。
   - **深入回答**：建议 `-Xms` 和 `-Xmx` 设为相同值，避免动态调整导致的额外开销。合理调整 `-Xmn`（新生代大小）和 `-XX:NewRatio`（新老年代比例）可以优化 GC 频率和吞吐量。

------

#### **2. JVM 性能监控工具**

**🔑 知识点详解**

1. **命令行工具**
   - `jps`：查看运行中的 JVM 进程。
   - `jstat`：监控 GC 和内存使用，如 `jstat -gcutil <pid> 1000`（每秒监控 GC 变化）。
   - `jstack`：打印线程堆栈信息，分析死锁等问题。
   - `jmap`：查看堆内存快照，如 `jmap -heap <pid>`。
   - `jinfo`：查看和修改 JVM 参数，如 `jinfo -flags <pid>`。
2. **可视化工具**
   - **JConsole**：实时监控 CPU、堆内存、GC、线程等。
   - **VisualVM**：提供内存快照、线程分析、CPU 监控等。
   - **Mission Control**（JDK 11+）：高级性能分析工具，适用于生产环境。
3. **日志监控**
   - `-XX:+PrintGCDetails`：记录 GC 详细信息。
   - `-XX:+PrintGCDateStamps`：GC 日志包含时间戳。
   - `-Xloggc:<file>`：将 GC 日志输出到文件。

**🔥 面试高频题**

1. 如何查看 JVM 运行状态？
   - **一句话答案**：使用 `jps` 获取进程 ID，再结合 `jstat`、`jmap`、`jstack` 等工具进行监控。
   - **深入回答**：可通过 `jstat -gcutil <pid>` 查看 GC 状态，使用 `jmap -heap <pid>` 查看内存分布，并借助 VisualVM 或 JConsole 进行可视化分析。如果 JVM 出现异常，可通过 `jstack <pid>` 分析线程堆栈，排查死锁等问题。

------

#### **3. JVM 调优案例分析**

**📝 案例 1：高吞吐量 Web 应用 GC 频繁导致卡顿**

**问题现象**：某 Web 服务在高并发时频繁发生 `Full GC`，导致请求延迟增加。
 **分析步骤**：

1. 通过 `jstat -gcutil <pid> 1000` 发现 `Full GC` 过于频繁。
2. 通过 `-XX:+PrintGCDetails` 观察 GC 日志，发现老年代增长过快，触发 `Full GC`。
3. 通过 `jmap -heap <pid>` 查看对象分布，发现短生命周期对象进入老年代。

**优化方案**：

- **调整 GC 策略**：切换至 `G1 GC`（`-XX:+UseG1GC`）。
- **优化内存分配**：调整 `-Xmx` 和 `-Xms`，增加新生代大小（`-Xmn`）。
- **减少老年代晋升**：调整 `-XX:SurvivorRatio=6`，增加 Survivor 区存活时间。

**优化结果**：GC 停顿时间降低 60%，吞吐量提高 20%。

**🔥 面试高频题**

1. 如何优化 GC 频繁触发的问题？
   - **一句话答案**：减少对象晋升老年代，调整新生代大小，并使用 G1 GC 优化吞吐量。
   - **深入回答**：可以通过 `-Xmn` 和 `-XX:SurvivorRatio` 调整对象存活时间，减少不必要的 `Full GC`。对于大流量系统，G1 GC 适用于低延迟需求，而 ZGC 可进一步降低 STW（JDK 11+）。

------